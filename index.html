<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Tree</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-feed { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; border-radius: 12px; transform: scaleX(-1); border: 2px solid rgba(255, 215, 0, 0.5); z-index: 10; opacity: 0.8; object-fit: cover; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }
        
        /* Loading Overlay */
        #loader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 50; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.5s; }
        .spinner { width: 50px; height: 50px; border: 3px solid rgba(255,215,0,0.3); border-radius: 50%; border-top-color: #ffd700; animation: spin 1s ease-in-out infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Status Indicator */
        .glass-panel { background: rgba(0, 20, 10, 0.6); backdrop-filter: blur(10px); border: 1px solid rgba(255, 215, 0, 0.2); box-shadow: 0 0 15px rgba(255, 215, 0, 0.1); }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 8px; box-shadow: 0 0 5px currentColor; }
        .dot-red { background-color: #ff4444; color: #ff4444; }
        .dot-green { background-color: #00ff88; color: #00ff88; }
        .dot-gold { background-color: #ffd700; color: #ffd700; }
    </style>
    
    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="spinner mb-4"></div>
        <h2 class="text-xl text-yellow-500 font-light tracking-widest">INITIALIZING MAGIC</h2>
        <p class="text-xs text-gray-500 mt-2">æ­£åœ¨å¯åŠ¨è§†è§‰å¼•æ“...</p>
    </div>

    <!-- UI Overlay -->
    <div id="ui-layer" class="p-6 flex flex-col justify-between">
        
        <!-- Header -->
        <div class="flex justify-between items-start">
            <div class="glass-panel p-4 rounded-lg pointer-events-auto max-w-sm">
                <h1 class="text-2xl font-bold text-yellow-400 mb-1" style="text-shadow: 0 0 10px rgba(255,215,0,0.5);">ğŸ„ Gesture Tree</h1>
                <p class="text-sm text-gray-300 mb-4">å“‘å…‰ç»¿ Â· è¾‰é‡‘ Â· åœ£è¯çº¢</p>
                
                <div class="space-y-2 text-xs text-gray-400">
                    <div class="flex items-center"><span class="w-4">âœŠ</span> æ¡æ‹³ï¼šèšåˆ (åœ£è¯æ ‘)</div>
                    <div class="flex items-center"><span class="w-4">ğŸ–</span> å¼ å¼€ï¼šæ•£å¼€ (æ˜Ÿäº‘)</div>
                    <div class="flex items-center"><span class="w-4">ğŸ‘‹</span> ç§»åŠ¨ï¼šæ—‹è½¬è§†è§’</div>
                    <div class="flex items-center"><span class="w-4">ğŸ‘Œ</span> æåˆï¼šæŠ“å–ç…§ç‰‡</div>
                </div>

                <div class="mt-4 pt-4 border-t border-white/10">
                    <label class="cursor-pointer bg-yellow-600/20 hover:bg-yellow-600/40 text-yellow-300 border border-yellow-500/50 px-3 py-1.5 rounded transition text-xs flex items-center justify-center gap-2">
                        <span>ğŸ“· ä¸Šä¼ ç…§ç‰‡ (åŠ å…¥äº‘å›¢)</span>
                        <input type="file" id="photo-input" accept="image/*" multiple class="hidden">
                    </label>
                </div>
            </div>
            
            <div class="glass-panel px-4 py-2 rounded-full flex items-center">
                <span id="gesture-indicator" class="status-dot dot-red"></span>
                <span id="gesture-text" class="text-xs font-mono uppercase tracking-wider">No Hand Detected</span>
            </div>
        </div>

    </div>

    <!-- Webcam Feed (Hidden logic, visible UI) -->
    <video id="video-feed" playsinline></video>
    
    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        // --- Configuration ---
        const CONFIG = {
            colors: {
                matteGreen: 0x0B6623,
                darkGreen: 0x013220,
                metallicGold: 0xFFD700,
                christmasRed: 0x8B0000,
                brightRed: 0xD40000
            },
            particleCount: 1200,
            photoCount: 12, // Default placeholders
            treeHeight: 30,
            treeRadius: 10,
            scatterRadius: 35
        };

        // --- Global State ---
        const state = {
            mode: 'TREE', // TREE, SCATTER, ZOOM
            handPresent: false,
            handPosition: { x: 0, y: 0 },
            rotationVelocity: 0,
            targetRotation: 0,
            pinchStrength: 0,
            targetZoomPhoto: null,
            uploadedTextures: []
        };

        // --- 3D Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 40);

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // --- Post Processing (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2; // è¾‰å…‰å¼ºåº¦
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xfffaed, 2);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const pointLight1 = new THREE.PointLight(CONFIG.colors.metallicGold, 3, 50);
        pointLight1.position.set(0, 10, 0);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(CONFIG.colors.christmasRed, 2, 50);
        pointLight2.position.set(-10, -5, 10);
        scene.add(pointLight2);

        // --- Object Groups ---
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);

        // 1. Instanced Mesh for Ornaments (Spheres, Cubes)
        const geometrySphere = new THREE.IcosahedronGeometry(0.6, 1);
        const geometryCube = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        
        const materialGold = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.metallicGold, 
            roughness: 0.2, 
            metalness: 0.9,
            emissive: 0xaa6600,
            emissiveIntensity: 0.2
        });
        const materialRed = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.christmasRed, 
            roughness: 0.3, 
            metalness: 0.5,
            emissive: 0x440000,
            emissiveIntensity: 0.4 
        });
        const materialGreen = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.matteGreen, 
            roughness: 0.8, 
            metalness: 0.1 
        });

        const instancedSpheresGold = new THREE.InstancedMesh(geometrySphere, materialGold, CONFIG.particleCount / 3);
        const instancedSpheresRed = new THREE.InstancedMesh(geometrySphere, materialRed, CONFIG.particleCount / 3);
        const instancedCubesGreen = new THREE.InstancedMesh(geometryCube, materialGreen, CONFIG.particleCount / 3);

        treeGroup.add(instancedSpheresGold);
        treeGroup.add(instancedSpheresRed);
        treeGroup.add(instancedCubesGreen);

        // Data arrays to store positions
        const objectsData = []; // { mesh, index, treePos, scatterPos, currentPos, velocity }

        function initInstancedObjects() {
            const meshes = [instancedSpheresGold, instancedSpheresRed, instancedCubesGreen];
            let totalIndex = 0;

            meshes.forEach(mesh => {
                const count = mesh.count;
                const dummy = new THREE.Object3D();

                for (let i = 0; i < count; i++) {
                    // Tree Position (Cone Spiral)
                    const theta = i * 0.5 + Math.random(); // Spiral angle
                    const y = (i / count) * CONFIG.treeHeight - CONFIG.treeHeight / 2; // -Height/2 to Height/2
                    const normalizedY = (y + CONFIG.treeHeight / 2) / CONFIG.treeHeight; // 0 to 1
                    const radius = (1 - normalizedY) * CONFIG.treeRadius + 1; // Radius shrinks as Y goes up
                    
                    const tx = Math.cos(theta) * radius;
                    const tz = Math.sin(theta) * radius;
                    const ty = y;

                    // Scatter Position (Sphere Random)
                    const u = Math.random();
                    const v = Math.random();
                    const phi = Math.acos(2 * u - 1) - Math.PI / 2;
                    const lambda = 2 * Math.PI * v;
                    const sr = CONFIG.scatterRadius * Math.cbrt(Math.random()); // Random inside sphere
                    
                    const sx = sr * Math.cos(phi) * Math.cos(lambda);
                    const sy = sr * Math.cos(phi) * Math.sin(lambda);
                    const sz = sr * Math.sin(phi);

                    // Initialize
                    dummy.position.set(tx, ty, tz);
                    dummy.scale.setScalar(Math.random() * 0.5 + 0.5);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);

                    objectsData.push({
                        type: 'instanced',
                        mesh: mesh,
                        index: i,
                        treePos: new THREE.Vector3(tx, ty, tz),
                        scatterPos: new THREE.Vector3(sx, sy, sz),
                        currentPos: new THREE.Vector3(tx, ty, tz),
                        dummy: dummy,
                        wobble: Math.random() * Math.PI
                    });
                    totalIndex++;
                }
            });
        }
        initInstancedObjects();

        // 2. Photos (Planes)
        const photoObjects = [];
        const photoGroup = new THREE.Group();
        treeGroup.add(photoGroup);

        function createPhotoMesh(texture) {
            const geometry = new THREE.PlaneGeometry(4, 4);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            // Add a golden frame
            const frameGeo = new THREE.BoxGeometry(4.2, 4.2, 0.1);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 1.0, roughness: 0.2 });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.z = -0.06;
            mesh.add(frame);

            return mesh;
        }

        // Placeholder Textures Generator
        function generatePlaceholderTexture(color, text) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0,0,256,256);
            ctx.fillStyle = 'white';
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        // Initialize default photos
        const defaultColors = ['#8B0000', '#0B6623', '#1A237E', '#4A148C'];
        for(let i=0; i<CONFIG.photoCount; i++) {
            const tex = generatePlaceholderTexture(defaultColors[i % 4], `Photo ${i+1}`);
            addPhotoToScene(tex, i);
        }

        function addPhotoToScene(texture, index) {
            const mesh = createPhotoMesh(texture);
            photoGroup.add(mesh);

            // Calc positions similar to instances
            const total = CONFIG.photoCount;
            const y = (index / total) * (CONFIG.treeHeight * 0.8) - CONFIG.treeHeight / 2.5;
            const normalizedY = (y + CONFIG.treeHeight / 2) / CONFIG.treeHeight;
            const radius = ((1 - normalizedY) * CONFIG.treeRadius) + 2; 
            const theta = index * (Math.PI * 2 / 3); // 3 spirals

            const tx = Math.cos(theta) * radius;
            const tz = Math.sin(theta) * radius;
            const ty = y;

            const sx = (Math.random() - 0.5) * CONFIG.scatterRadius * 1.5;
            const sy = (Math.random() - 0.5) * CONFIG.scatterRadius * 1.5;
            const sz = (Math.random() - 0.5) * CONFIG.scatterRadius * 0.5 + 10; // Closer to camera in scatter

            const data = {
                type: 'photo',
                mesh: mesh,
                treePos: new THREE.Vector3(tx, ty, tz),
                scatterPos: new THREE.Vector3(sx, sy, sz),
                currentPos: new THREE.Vector3(tx, ty, tz),
                zoomPos: new THREE.Vector3(0, 0, 15), // Close up position
                isZoomTarget: false
            };
            
            // Initial Pos
            mesh.position.copy(data.treePos);
            mesh.lookAt(0, y, 0); // Look at center pole
            
            objectsData.push(data);
            photoObjects.push(data);
        }

        // 3. The Star
        const starGeo = new THREE.OctahedronGeometry(1.5, 0);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const starMesh = new THREE.Mesh(starGeo, starMat);
        starMesh.position.y = CONFIG.treeHeight / 2 + 1;
        treeGroup.add(starMesh);

        // Add star glow sprite
        const spriteMap = new THREE.TextureLoader().load( 'https://threejs.org/examples/textures/sprites/spark1.png' );
        const spriteMaterial = new THREE.SpriteMaterial( { map: spriteMap, color: 0xffffee, transparent: true, blending: THREE.AdditiveBlending } );
        const sprite = new THREE.Sprite( spriteMaterial );
        sprite.scale.set(10, 10, 1);
        starMesh.add( sprite );


        // --- File Upload Logic ---
        document.getElementById('photo-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if (!files.length) return;

            // Remove old placeholders if it's the first upload
            if (state.uploadedTextures.length === 0) {
                 photoObjects.forEach(p => {
                     p.mesh.visible = false; // Hide old ones for now
                     // In a real app we'd dispose geometry/material
                 });
                 // We reuse the positions of the hidden/removed objects or create new ones
            }

            Array.from(files).forEach((file, i) => {
                const url = URL.createObjectURL(file);
                new THREE.TextureLoader().load(url, (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    state.uploadedTextures.push(tex);
                    
                    // Replace a placeholder or add new
                    const targetIndex = (state.uploadedTextures.length - 1) % photoObjects.length;
                    const targetObj = photoObjects[targetIndex];
                    
                    targetObj.mesh.material.map = tex;
                    targetObj.mesh.material.needsUpdate = true;
                    targetObj.mesh.visible = true;
                });
            });
        });

        // --- Logic: Update Visuals ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            const dt = clock.getDelta();

            // 1. Star Rotation
            starMesh.rotation.y = time;
            sprite.material.opacity = 0.5 + Math.sin(time * 3) * 0.2;

            // 2. Camera / Group Rotation based on hand
            if (state.mode === 'SCATTER' && state.handPresent) {
                // Smoothly interpolate rotation velocity based on hand x
                const targetVel = (state.handPosition.x - 0.5) * 2.0; // -1 to 1
                state.rotationVelocity += (targetVel - state.rotationVelocity) * 0.05;
            } else {
                // Auto rotate slowly if no hand or in tree mode
                state.rotationVelocity += (0.1 - state.rotationVelocity) * 0.02;
            }
            
            treeGroup.rotation.y += state.rotationVelocity * 0.05;


            // 3. Particle & Photo Interpolation
            objectsData.forEach(obj => {
                let target;

                if (state.mode === 'TREE') {
                    target = obj.treePos;
                } else if (state.mode === 'SCATTER') {
                    target = obj.scatterPos;
                } else if (state.mode === 'ZOOM') {
                    if (obj.isZoomTarget) {
                        // The specific photo being zoomed
                        // We need to counter-rotate position so it stays in front of camera
                        // Or easier: attach it to camera? 
                        // For this demo: move it to a world position near camera and look at camera
                        
                        // Simple approach: Move to calculated world position
                        const camDir = new THREE.Vector3();
                        camera.getWorldDirection(camDir);
                        target = camera.position.clone().add(camDir.multiplyScalar(10));
                    } else {
                        // Push others away slightly or keep scattered
                        target = obj.scatterPos;
                    }
                }

                // Interpolate Position
                const lerpFactor = 0.05;
                obj.currentPos.lerp(target, lerpFactor);

                // Add some floating noise
                const noiseY = Math.sin(time + obj.wobble) * 0.05;

                // Update Mesh
                if (obj.type === 'instanced') {
                    obj.dummy.position.copy(obj.currentPos);
                    obj.dummy.position.y += noiseY;
                    
                    if (state.mode === 'TREE') {
                        // Look away from center
                        obj.dummy.lookAt(obj.dummy.position.clone().multiplyScalar(2));
                    } else {
                        obj.dummy.rotation.x += 0.01;
                        obj.dummy.rotation.y += 0.01;
                    }

                    obj.dummy.updateMatrix();
                    obj.mesh.setMatrixAt(obj.index, obj.dummy.matrix);
                } else if (obj.type === 'photo') {
                    obj.mesh.position.copy(obj.currentPos);
                    obj.mesh.position.y += noiseY;

                    if (state.mode === 'ZOOM' && obj.isZoomTarget) {
                        obj.mesh.lookAt(camera.position);
                        // Scale up
                        obj.mesh.scale.lerp(new THREE.Vector3(2, 2, 2), 0.1);
                    } else if (state.mode === 'TREE') {
                        obj.mesh.lookAt(0, obj.mesh.position.y, 0);
                        obj.mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                    } else {
                        // Scatter mode: slow rotation
                        obj.mesh.lookAt(camera.position);
                        obj.mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                    }
                }
            });

            // Mark instance matrices as needing update
            instancedSpheresGold.instanceMatrix.needsUpdate = true;
            instancedSpheresRed.instanceMatrix.needsUpdate = true;
            instancedCubesGreen.instanceMatrix.needsUpdate = true;

            composer.render();
        }

        // --- MediaPipe Logic ---
        const videoElement = document.getElementById('video-feed');
        const gestureIndicator = document.getElementById('gesture-indicator');
        const gestureText = document.getElementById('gesture-text');
        
        function onResults(results) {
            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => document.getElementById('loader').style.display = 'none', 500);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                state.handPresent = true;
                
                // Get normalized coordinates
                // MediaPipe: x (0 left, 1 right), y (0 top, 1 bottom)
                // We map this to control UI
                const wrist = landmarks[0];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const thumbTip = landmarks[4];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];

                state.handPosition.x = 1 - wrist.x; // Mirror effect
                state.handPosition.y = wrist.y;

                // 1. Calculate Openness (Distance of tips from wrist)
                const tips = [indexTip, middleTip, ringTip, pinkyTip];
                let avgDist = 0;
                tips.forEach(tip => {
                    const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                    avgDist += d;
                });
                avgDist /= 4;

                // 2. Calculate Pinch (Thumb to Index)
                const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

                // --- State Machine Logic ---
                
                // Priority 1: Pinch (Grab Photo)
                if (pinchDist < 0.05) {
                    if (state.mode === 'SCATTER' || state.mode === 'ZOOM') {
                        setMode('ZOOM');
                        updateStatus('dot-gold', 'GRABBING PHOTO');
                        
                        // If we haven't selected a photo yet, pick the one closest to "hand projection" or center
                        if (!state.targetZoomPhoto) {
                            // Simple logic: Pick random or closest to center of screen
                            // For true interactivity, we'd project hand x/y to raycaster
                            // Here: Pick closest photo to camera in SCATTER mode
                            let closest = null;
                            let minD = Infinity;
                            photoObjects.forEach(p => {
                                const d = p.mesh.position.distanceTo(camera.position);
                                if(d < minD) { minD = d; closest = p; }
                            });
                            state.targetZoomPhoto = closest;
                            if(closest) closest.isZoomTarget = true;
                        }
                    }
                } 
                // Priority 2: Fist (Close Tree)
                else if (avgDist < 0.25) { 
                    setMode('TREE');
                    updateStatus('dot-green', 'TREE FORM (CLOSED)');
                    resetZoom();
                } 
                // Priority 3: Open Hand (Scatter)
                else if (avgDist > 0.35) {
                    if (state.mode !== 'ZOOM') { // Don't break zoom easily
                        setMode('SCATTER');
                        updateStatus('dot-red', 'SCATTER FORM (OPEN)');
                        resetZoom();
                    }
                }
                
                // Handle Zoom exit if hand opens wide
                if (state.mode === 'ZOOM' && avgDist > 0.5) {
                    setMode('SCATTER');
                    resetZoom();
                }

            } else {
                state.handPresent = false;
                updateStatus('dot-red', 'NO HAND DETECTED');
            }
        }

        function setMode(newMode) {
            if (state.mode === newMode) return;
            state.mode = newMode;
        }

        function resetZoom() {
            state.targetZoomPhoto = null;
            photoObjects.forEach(p => p.isZoomTarget = false);
        }

        function updateStatus(colorClass, text) {
            gestureIndicator.className = `status-dot ${colorClass}`;
            gestureText.innerText = text;
        }

        // Initialize MediaPipe
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        
        cameraUtils.start();

        // Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start Loop
        animate();

    </script>
</body>
</html>
